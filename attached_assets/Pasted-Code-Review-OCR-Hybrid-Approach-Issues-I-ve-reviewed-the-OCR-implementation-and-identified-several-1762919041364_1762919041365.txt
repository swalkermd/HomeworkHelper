Code Review: OCR Hybrid Approach Issues
I've reviewed the OCR implementation and identified several critical issues that are likely causing failures. Here's my analysis:

Critical Issues Found:
1. Image Format Validation & Conversion (googleVision.ts:34)
// Current code:
const base64Data = base64Image.replace(/^data:image\/\w+;base64,/, '');
Problems:

The regex \w+ only matches alphanumeric characters, missing formats like image/svg+xml
No validation that remaining content is valid base64
No handling for non-data-URI formats (file paths, HTTP URLs)
No size limit checks (Google Vision has 20MB limit)
Recommendation:

// Improved validation
function prepareImageForVision(imageUri: string): string {
  // Remove various data URI prefixes
  let base64Data = imageUri.replace(/^data:image\/[^;]+;base64,/, '');
  
  // Validate it's actually base64
  if (!/^[A-Za-z0-9+/]*={0,2}$/.test(base64Data)) {
    throw new Error('Invalid base64 image data');
  }
  
  // Check size (rough estimate: base64 is ~1.37x original size)
  const estimatedSize = (base64Data.length * 0.75) / (1024 * 1024); // MB
  if (estimatedSize > 20) {
    throw new Error(`Image too large (${estimatedSize.toFixed(1)}MB). Max: 20MB`);
  }
  
  return base64Data;
}
2. Silent Fallback Hides Real Errors (proxy.ts:1299-1302)
} catch (ocrError) {
  console.error('‚ö†Ô∏è Google Vision OCR failed, falling back to GPT-4o vision only:', ocrError);
  useHybridOCR = false;
}
Problems:

All OCR errors are caught and silently ignored
No distinction between API key issues, network errors, or invalid image formats
Users never know when hybrid mode fails
Makes debugging nearly impossible
Recommendation:

} catch (ocrError) {
  const errorMessage = ocrError instanceof Error ? ocrError.message : String(ocrError);
  
  // Log detailed error information
  console.error('‚ö†Ô∏è Google Vision OCR failed:', {
    error: errorMessage,
    errorType: ocrError?.constructor?.name,
    stack: ocrError instanceof Error ? ocrError.stack : undefined
  });
  
  // Provide specific feedback for common issues
  if (errorMessage.includes('API key')) {
    console.error('üîë CRITICAL: Google Vision API key is invalid or missing');
  } else if (errorMessage.includes('Invalid base64')) {
    console.error('üì∑ Image format error: Unable to process image data');
  } else if (errorMessage.includes('too large')) {
    console.error('üì¶ Image size error:', errorMessage);
  }
  
  // Still fall back, but with better logging
  useHybridOCR = false;
}
3. No Timeout Protection for Google Vision API (googleVision.ts:59)
const response = await fetch(url, {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify(requestBody)
});
Problems:

No timeout specified, could hang indefinitely
No retry logic for transient failures
No rate limit handling
Recommendation:

const controller = new AbortController();
const timeoutId = setTimeout(() => controller.abort(), 30000); // 30s timeout

try {
  const response = await fetch(url, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(requestBody),
    signal: controller.signal
  });
  
  clearTimeout(timeoutId);
  
  // ... rest of code
} catch (error) {
  clearTimeout(timeoutId);
  if (error.name === 'AbortError') {
    throw new Error('Google Vision API request timed out after 30 seconds');
  }
  throw error;
}
4. Insufficient Error Context (googleVision.ts:67-69)
if (!response.ok) {
  const errorData = await response.json().catch(() => ({}));
  throw new Error(`Google Vision API error: ${response.status} - ${JSON.stringify(errorData)}`);
}
Problems:

Doesn't distinguish between 4xx (client errors) and 5xx (server errors)
No specific handling for 401/403 (auth issues)
No handling for 429 (rate limits)
Recommendation:

if (!response.ok) {
  const errorData = await response.json().catch(() => ({}));
  
  // Provide specific error messages
  if (response.status === 401 || response.status === 403) {
    throw new Error('Google Vision API authentication failed. Check API key permissions.');
  } else if (response.status === 429) {
    throw new Error('Google Vision API rate limit exceeded. Please try again later.');
  } else if (response.status === 400) {
    throw new Error(`Invalid request to Google Vision API: ${errorData.error?.message || 'Bad request'}`);
  } else if (response.status >= 500) {
    throw new Error(`Google Vision API server error (${response.status}). Please try again.`);
  } else {
    throw new Error(`Google Vision API error: ${response.status} - ${JSON.stringify(errorData)}`);
  }
}
5. Missing Confidence Threshold Logic (proxy.ts:1290-1295)
const ocrResult = await extractTextFromImage(imageUri);
ocrText = formatOCRText(ocrResult.text);
ocrConfidence = ocrResult.confidence;
useHybridOCR = true;
Problems:

No check for empty OCR results
No confidence threshold (uses OCR even with 1% confidence)
Low confidence results might be worse than GPT-4o alone
Recommendation:

const ocrResult = await extractTextFromImage(imageUri);
ocrText = formatOCRText(ocrResult.text);
ocrConfidence = ocrResult.confidence;

// Only use OCR if we have reasonable confidence and actual text
const MIN_CONFIDENCE = 0.60; // 60% minimum confidence
const MIN_TEXT_LENGTH = 3; // At least a few characters

if (ocrText.length >= MIN_TEXT_LENGTH && ocrConfidence >= MIN_CONFIDENCE) {
  useHybridOCR = true;
  console.log(`‚úÖ OCR extraction complete. Confidence: ${(ocrConfidence * 100).toFixed(1)}%, Text length: ${ocrText.length} chars`);
  console.log(`üìù OCR Preview: ${ocrText.substring(0, 200)}...`);
} else {
  console.log(`‚ö†Ô∏è OCR confidence too low (${(ocrConfidence * 100).toFixed(1)}%) or insufficient text. Falling back to GPT-4o vision only.`);
  useHybridOCR = false;
}
6. Missing Image Preprocessing
Problems:

No image optimization (compression, resolution adjustment)
Large images waste API quota and slow processing
No conversion for unsupported formats
Recommendation: Add image preprocessing before sending to Google Vision:

Resize large images to reasonable dimensions (e.g., max 2048x2048)
Compress to reduce file size while maintaining readability
Convert to JPEG/PNG if needed
Additional Recommendations:
Add Monitoring/Telemetry:

Track OCR success/failure rates
Monitor average confidence scores
Log hybrid vs. fallback usage
Implement Retry Logic:

Use exponential backoff for transient failures
Retry only on network errors, not on 4xx errors
Add Health Check Endpoint:

app.get('/api/ocr-health', async (req, res) => {
  try {
    const available = await isGoogleVisionAvailable();
    if (!available) {
      return res.status(503).json({ status: 'unavailable', reason: 'API key not configured' });
    }
    
    // Optional: test with a small dummy image
    // const testResult = await extractTextFromImage(SMALL_TEST_IMAGE);
    
    res.json({ status: 'healthy', mode: 'hybrid' });
  } catch (error) {
    res.status(503).json({ 
      status: 'unhealthy', 
      error: error.message 
    });
  }
});
Environment Variable Validation: Add startup checks to validate API keys are properly configured:

// At server startup
if (!process.env.GOOGLE_CLOUD_VISION_API_KEY) {
  console.warn('‚ö†Ô∏è GOOGLE_CLOUD_VISION_API_KEY not set - hybrid OCR disabled');
} else {
  console.log('‚úÖ Google Cloud Vision API configured for hybrid OCR');
}
Better Test Coverage: The test file test-production-ocr.html uses a 1x1 pixel image which won't contain any text. Create better test cases with actual text.

Priority Fixes:
HIGH PRIORITY:

Add image format validation and size limits
Implement timeout protection for Google Vision API calls
Add confidence threshold logic
Improve error messages and distinction
MEDIUM PRIORITY: 5. Add retry logic with exponential backoff 6. Implement monitoring/telemetry 7. Add health check endpoint

LOW PRIORITY: 8. Image preprocessing/optimization 9. Better test coverage